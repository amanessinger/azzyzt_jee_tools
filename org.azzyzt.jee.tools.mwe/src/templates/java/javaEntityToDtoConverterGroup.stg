<!
 * Copyright (c) 2011, Municipiality of Vienna, Austria
 *
 * Licensed under the EUPL, Version 1.1 or – as soon they
 * will be approved by the European Commission - subsequent
 * versions of the EUPL (the "Licence");
 * You may not use this work except in compliance with the
 * Licence.
 * 
 * For convenience a plain text copy of the English version 
 * of the Licence can be found in the file LICENCE.txt in
 * the top-level directory of this software distribution.
 * 
 * You may obtain a copy of the Licence in any of 22 European
 * Languages at:
 *
 * http://www.osor.eu/eupl
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the Licence is
 * distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the Licence for the specific language governing
 * permissions and limitations under the Licence.
 !>

<!
 * Code generation makes use of and bundles a copy of StringTemplate, 
 * which is
 * 
 * Copyright (c) 2008, Terence Parr
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the 
 * following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright 
 * notice, this list of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright 
 * notice, this list of conditions and the following disclaimer in 
 * the documentation and/or other materials provided with the distribution.
 * 
 * Neither the name of the author nor the names of its contributors 
 * may be used to endorse or promote products derived from this software 
 * without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE 
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 !>

group javaEntityToDtoConverterGroup : javaGroup;

javaClass(mdt, generator) ::= <<
package <mdt.packageName>;

<mdt:importDeclarations()>

/**
 * Generated class <mdt.fqName>
 */
<mdt:annotations()><mdt.modifiers> class <mdt.simpleName><extendsClasses(mdt)><implementsInterfaces(mdt)> {

    private static final long serialVersionUID = 1L;

    <mdt.fields:fieldDeclaration()>
    <defaultConstructor(mdt)>
    <fromEntity(mdt=mdt, entity=mdt.properties.entity, dto=mdt.properties.dto)>
    <fromDto(mdt=mdt, entity=mdt.properties.entity, dto=mdt.properties.dto)>
}
>>



fromEntity(mdt, entity, dto) ::= <<
public <dto.simpleName> fromEntity(<entity.simpleName> in) {
    <dto.simpleName> result = new <dto.simpleName>();
    
    <entity.fields:copyFieldE2D()>
    return result;
}

>>

copyFieldE2D() ::= <<
<if(attr.internal)><else>
<if(attr.holdingAssociationEndpoint)><copyFieldE2DIds(attr)><else><copyFieldE2DSimple(attr)><endif>
<endif>
>>

copyFieldE2DSimple(field) ::= <<
result.set<field.ucName>(in.get<field.ucName>());

>>

copyFieldE2DIds(field) ::= <<
<if(field.holdingMultivaluedAssociationEndpoint)>
<copyMultipleAssociationIds(field)>
<else>
<copySingleAssociationId(field)>
<endif>

>>

copySingleAssociationId(field) ::= <<
if (in.get<field.ucName>() != null) {
    result.set<field.ucName>Id(in.get<field.ucName>().getId());
}

>>

copyMultipleAssociationIds(field) ::= <<
<if(field.associationEndpoint.fetchTypeEager)>
for (<field.fieldType.entityMemberType.simpleName> entity : in.get<field.ucName>()<if(field.fieldType.map)>.values()<endif>) {
    result.get<field.ucName>Ids().add(entity.getId());
}

<else>
/*
 * No IDs for LAZYly fetched association to <field.fieldType.entityMemberType.simpleName> are transported. 
 * Access them via an extra service call if needed. Bomb out if client tries to use them.
 */
result.set<field.ucName>Ids(null);

<endif>

>>



fromDto(mdt, entity, dto) ::= <<
public <entity.simpleName> fromDto(<dto.simpleName> in) 
throws EntityNotFoundException, EntityInstantiationException, InvalidIdException
{
    <entity.simpleName> result = eao.findOrCreate(<entity.simpleName>.class, in.getId());
    
    <entity.fields:copyFieldD2E()>
    return result;
}

>>

copyFieldD2E() ::= <<
<if(attr.internal)><else>
<if(attr.holdingAssociationEndpoint)><fetchAssociatedEntities(attr)><else><copyFieldD2ESimple(attr)><endif>
<endif>
>>

copyFieldD2ESimple(field) ::= <<
<if(field.idField)>if (EntityBase.couldBeIdValue(in.get<field.ucName>())) {
    // may have been newly created, don't overwrite it with null or zero!
    result.set<field.ucName>(in.get<field.ucName>());
}

<elseif(field.notAutomaticallySet)>
result.set<field.ucName>(in.get<field.ucName>());

<elseif(field.createUserField)>if (result.get<field.ucName>() != null) {
    // only set if not already set!
    result.set<field.ucName>(invocationRegistry.getMetaInfo().getAuthenticatedUserName());
}

<elseif(field.modificationUserField)>
result.set<field.ucName>(invocationRegistry.getMetaInfo().getAuthenticatedUserName());

<else>
// a value for <field.name> is automatically set by the persistence system 

<endif>

>>

fetchAssociatedEntities(field) ::= <<
<if(field.holdingMultivaluedAssociationEndpoint)>
<fetchMultipleAssociatedEntities(field)>
<else>
<fetchSingleAssociatedEntity(field)>
<endif>

>>

fetchSingleAssociatedEntity(field) ::= <<
if (in.get<field.ucName>Id() != null) {
    <field.fieldType.SimpleName> entity = eao.findOrInvalidId(<field.fieldType.SimpleName>.class, in.get<field.ucName>Id());
    result.set<field.ucName>(entity);
}

>>

fetchMultipleAssociatedEntities(field) ::= <<
List\<<field.fieldType.entityMemberType.idField.fieldType.simpleName>\> <field.name>Ids = in.get<field.ucName>Ids();
<if(field.fieldType.list)><initializedList(type=field.fieldType.entityMemberType.simpleName, name={all<field.ucName>})><endif>
<if(field.fieldType.set)><initializedSet(type=field.fieldType.entityMemberType.simpleName, name={all<field.ucName>})><endif>
<if(field.fieldType.map)>
<initializedMap(keytype=field.fieldType.entityMemberType.idField.fieldType.simpleName, 
                valuetype=field.fieldType.entityMemberType.simpleName, 
                name={all<field.ucName>})>
<endif>

<fetchEntitiesLoop(field=field, keytype=field.fieldType.entityMemberType.idField.fieldType.simpleName, valuetype=field.fieldType.entityMemberType.simpleName, idsName={<field.name>Ids}, entitiesName={all<field.ucName>})>

>>

fetchEntitiesLoop(field, keytype, valuetype, idsName, entitiesName) ::= <<
for (<keytype> id : <idsName>) {
    <valuetype> entity = eao.findOrInvalidId(<valuetype>.class, id);
    <if(field.fieldType.map)>
    <entitiesName>.put(id, entity)
    <else>
    <entitiesName>.add(entity)
    <endif>;
}
>>
