<!
 * Copyright (c) 2011, Municipiality of Vienna, Austria
 *
 * Licensed under the EUPL, Version 1.1 or – as soon they
 * will be approved by the European Commission - subsequent
 * versions of the EUPL (the "Licence");
 * You may not use this work except in compliance with the
 * Licence.
 * 
 * For convenience a plain text copy of the English version 
 * of the Licence can be found in the file LICENCE.txt in
 * the top-level directory of this software distribution.
 * 
 * You may obtain a copy of the Licence in any of 22 European
 * Languages at:
 *
 * http://www.osor.eu/eupl
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the Licence is
 * distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the Licence for the specific language governing
 * permissions and limitations under the Licence.
 !>

<!
 * Code generation makes use of and bundles a copy of StringTemplate, 
 * which is
 * 
 * Copyright (c) 2008, Terence Parr
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or 
 * without modification, are permitted provided that the 
 * following conditions are met:
 * 
 * Redistributions of source code must retain the above copyright 
 * notice, this list of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright 
 * notice, this list of conditions and the following disclaimer in 
 * the documentation and/or other materials provided with the distribution.
 * 
 * Neither the name of the author nor the names of its contributors 
 * may be used to endorse or promote products derived from this software 
 * without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE 
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 !>

group javaGroup;

javaClass(mdt, generator) ::= <<
package <mdt.packageName>;

<mdt:importDeclarations()>

/**
 * Generated class <mdt.fqName>
 */
<mdt:annotations()><@extra_class_annotations()><mdt.modifiers> class <mdt.simpleName><extendsClasses(mdt)><implementsInterfaces(mdt)> {

    <if(mdt.serialVersionNeeded)>
    private static final long serialVersionUID = 1L;
    
    <endif>
    <if(generator.generateFields)><mdt.fields:fieldDeclaration()><endif>
    <@extra_fields()>
    <if(generator.generateDefaultConstructor)><defaultConstructor(mdt)><endif>
    <@extra_constructors()>
    <if(generator.generateGettersSetters)><mdt.fields:getterSetter()><endif>
    <mdt.methods:classMethodDeclaration()>
    <@extra_methods()>
}
>>

javaInterface(mdt, generator) ::= <<
package <mdt.packageName>;

<mdt:importDeclarations()>

/**
 * Generated interface <mdt.fqName>
 */
<mdt:annotations()><@extra_interface_annotations()><mdt.modifiers> interface <mdt.simpleName><extendsClasses(mdt)> {

    <mdt.methods:interfaceMethodDeclaration()>
    <@extra_methods()>
}
>>

importDeclarations(mdt) ::= <<
<mdt.referencedForeignTypes:import()><@extraImports()>
>>

import() ::= <<
import <attr.fqName>;

>>

annotations(annotated) ::= <<
<annotated.metaAnnotationInstances:annotation()>
>>

annotation() ::= <<
@<attr.name><if(attr.notEmpty)>(<attr.elements.keys:{k|<k>=<attr.elements.(k)>}; separator=", ">)<endif>

>>

fieldDeclaration() ::= <<
<attr:annotations()><attr.fieldType.shortName> <attr.name><if(attr.initializer)> = <attr.initializer><endif>;


>>

defaultConstructor(mdt) ::= <<
public <mdt.simpleName>() { super(); }


>>

getterSetter() ::= <<
<attr.getterMetaAnnotationInstances:annotation()>public <attr.fieldType.shortName> get<attr.ucName>() {
    return this.<attr.name>;
}

<attr.setterMetaAnnotationInstances:annotation()>public void set<attr.ucName>(<attr.fieldType.shortName> <attr.name>) {
    this.<attr.name> = <attr.name>;
}


>>

extendsClasses(mdt) ::= <<
<if(mdt.superMetaClass)> extends <mdt.superMetaClass.shortName><mdt.superMetaClass.shortTypeParameterString><endif>
>>

implementsInterfaces(mdt) ::= <<
<if(mdt.implementingInterfaces)> implements <mdt.interfaces:interfaceList(); separator=", "><endif>
>>

interfaceList() ::= <<
<attr.simpleName><attr.shortTypeParameterString>
>>

classMethodDeclaration() ::= <<
<attr.modifiers> <attr.returnType.shortName> <attr.name>(<attr.signature:parameterList(); separator=", ">) {
    <if(attr.notVoid)><attr.returnType.shortName> result<if(attr.returnType.canBeNull)> = null<endif>;
    
    // TODO implement body
    
    return result;
    <else>
    // TODO implement body
    
    <endif>
}


>>

interfaceMethodDeclaration() ::= <<
<attr.modifiers> <attr.returnType.shortName> <attr.name>(<attr.signature:parameterList(); separator=", ">);

>>

parameterList() ::= <<
<attr.type.shortName> <attr.name>
>>


initializedList(type, name) ::= <<
List\<<type>\> <name> = new ArrayList\<<type>\>();
>>

initializedSet(type, name) ::= <<
Set\<<type>\> <name> = new HashSet\<<type>\>();
>>

initializedMap(keytype, valuetype, name) ::= <<
Map\<<keytype>, <valuetype>\> <name> = new HashMap\<<keytype>, <valuetype>\>();
>>

